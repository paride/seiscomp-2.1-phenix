.TH GCFLIB 3 "July 1998" "ISTI" "GCF MANUAL PAGES"
.SH NAME
gcf_open, gcf_read, gcfhdr_read, gcfhdr_print, gcfhdr_printstatus, gcf_serial2disk \- process Guralp Compressed Format packets off of a UNIX disk or serial port.
.SH SYNOPSIS
.nf
.ft B
#include "gcf.h"
#include "gcf_term.h"
.ft
.fi
.LP
.nf
.ft B
int check_speed(speed_t * speed)
.ft
.fi
.LP
.nf
.ft B
int gcf_open(char * term_dev, speed_t speed)
.ft
.fi
.LP
.nf
.ft B
int gcf_read(int fd, char **buf)
.ft
.fi
.LP
.nf
.ft B
int gcfhdr_read(char *buf, GCFhdr *hdr, int type)
.ft
.fi
.LP
.nf
.ft B
void gerror(char *str)
.ft
.fi
.LP
.nf
.ft B
int gepoch2gmt (Gepoch *epoch, Time *time)
.ft
.fi
.LP
.nf
.ft B
void gcfhdr_print(GCFhdr *hdr, FILE *fptr)
.ft
.fi
.LP
.nf
.ft B
void gcfhdr_printstatus(GCFhdr *hdr, FILE *fptr)
.ft
.fi
.LP
.nf
.ft B
void gcf_serial2disk(char * inbuf, char * outbuf)
.ft
.fi
.SH DESCRIPTION
.LP
The gcflib functions describe an interface library that application developers
can use to access data in GCF format from a Guralp Systems DM24 module via a 
UNIX serial port. The functions provided open a serial port, read a transmission 
protocol packet, and convert the packet into a gcf header structure (GCFhdr).
Alternatively the user may write the GCHhdr into a UNIX file or read a
GCFhdr from a UNIX file system. 
.LP
Many of the gcfhdr_ functions described here have a 
.I GCFhdr
argument that is a pointer to a
.B gcf_head
structure.
This structure contains the following members:
.br
.ne 9
.LP
.ft B
.ta .2i .55i 1.3i 1.8i 2.8i
.nf
typedef struct gcf_head {
	long		disk_addr; 	/* internal use only */
	long	stream_num; 		/* internal use only */
	char	system_id[8];		/* digitizing system identifier */
	char	stream_id[8];		/* channel/stream identifier */
	Gepoch	epoch;			/* Guralp Epoch notation */
	long	num_samps;		/* number of samples in data, chars if sample_rate==0 */
	long	num_records;		/* number of compressed records */
	long	compress_format;	/* 1, 2, or 4 */
	long	sample_rate;		/* in sps, 0 indicates SOH block in data */
	long	reserved;		/* reserved from GCF header */
	long	max;			/* maximum value in data array */
	long	min;			/* minimum value in data array */
	long	data[1000];		/* data array in native byte order, chars if sample_rate==0 */
} GCFhdr;
typedef struct gcf_epoch {
        long day_epoch;         /* days since Nov 17, 1989 */
        long sec_per_day;       /* number of seconds into this day */
} Gepoch;
.fi
.ft
.LP
.B check_speed(\|)
accepts a pointer to a speed_t value that is an integer representation of the baud rate 
desired and returns a termios #define for the proper baud rate. Valid input baud rates are:
1200, 2400, 4800, 9600, 19200, and 38400. The function returns a -1 if the baud rate
supplied is not valid and a 0 if the data are valid. The termios #define is returned in 
the speed_t pointer passed to the function.
.LP
.B gcf_open(\|)
opens a serial port to the termios baud rate specified and returns a file-descriptor to
the open device. The connection opened is expected to be a DUPLEX connection such that
acknowledge (ACK) and resend (NACK) transmissions can be sent to the digitizer. On error, 
this function returns a -1 and a message is printed to stderr.
.LP
.B gcf_read(\|)
reads a single GCF transmission protocol packet from serial port opened using 
.B gcf_open. 
The function negotiates for the packet using ACK and NACK commands over the DUPLEX connection. 
It confirms that the packet read passes checksum verification. 
The transmission packet is returned as a pointer to a statically allocated buffer
by the char ** pointer argument. The 
.B gcf_read 
function will block waiting for a complete packet.
Upon failure, or EOF, the function returns a -1.
Upon success the block number, modulo 256 is returned. 
Since the buffer passed back by 
.B gcf_read 
is a statically allocated array, it should not be 
\fBfree(\|)\fR'ed. 
The buffer passed back should be
passed into the 
.B gcfhdr_read 
function with the type argument set to \fBGCRTP\fR.
.LP
.B gcfhdr_read(\|)
reads a raw GCF packet, obtained via 
.B gcf_read 
or from disk, into a GCFhdr structure. If the packet, passed as a char array, was read
from a file, then the type argument should be set to the token \fBGCFDISK\fR. If the
packet was read from a serial port using 
.B gcf_read 
then the type argument should be set to \fBGCFTP\fR. If the data being passed are from
a UDP socket from the SCREAM program, then the type should be set to \fBGCFUDP\fR.
The function returns 0 upon successful
reading of a packet into the GCFhdr structure. Upon failure, the function returns -1 and
sets the external int gcf_error variable. The error can be printed to standard error using
the \fBgerror\fR function described below. The GCFhdr structure contains data in native
byte order unless the sample rate is zero in which case the data array contain a char 
array of STATUS information. If the sample_rate member is zero, then the num_samps member
contains the number of chars in the data array.
.LP
.B gepoch2gmt(\|)
converts a Guralp epoch structure into a more human readable time structure. Only the 
year, day_of_year, hour, min, sec, and msec members of this structure are set upon
return.
.LP
.ft B
.ta .2i .55i 1.3i 1.8i 2.8i
.nf
typedef struct time_type {
        short   year;           /* year including century */
        short   day_of_year;    /* day into year */
        short   mo;             /* month */
        short   day;            /* day of month */
        short   hour;           /* hour (24hr clock */
        short   min;            /* minutes */
        short   sec;            /* seconds */
        short   msec;           /* milliseconds */
        short   usec;           /* microseconds, set if precision allows */
} Time;
.fi
.ft
.LP
.B gerror(\|)
is to be called upon failure of \fBgcfhdr_read\fR and prints a error message to standard error.
See \fBGCF ERRORS\fR section below for details of the errors.
.LP
.B gcfhdr_print(\|)
outputs, to the file pointer provided, a one line string describing the contents of the GCHhdr
structure. An example line:
.nf

SyID: WO0080 StrmID: 0080E2 NS:  500 SPS:  100 CFmt: 2 1997:200:14:56:34

.fi
shows the system identifier (SyID:), the channel or stream identifier (StrmID:), the number
of samples (NS:), the sample rate in samples per second (SPS:), the compression format (CFmt:)
and the time of the start of the packet.
.LP
.B gcfhdr_printstatus(\|)
outputs a string of the STATUS block information, from the data member of the GCFhdr 
structure, to the file pointer provided. This function should only be called when a
status block is obtained from \fBgcf_read\fR (when the sample rate in the GCFhdr is 0).
.LP
.B gcf_serial2disk(\|)
converts a packet obtained with \fBgcf_read\fR into a 1024 byte GCF disk packet.
.SH EXAMPLE CODE

Below is a small snippet of code to demonstrate how the above functions can be used
to read from a serial port /dev/ttya at 9600 baud:

.nf
	#include "gcf.h"
	#include "gcf_term.h"
	GCFhdr hdr;
	char * cptr;
	speed_t speed;
	int    gfd, block_no;

		speed = 9600;		/* set baud rate to 9600 */
		check_speed(&speed);	/* convert int baud rate to #define */
		gfd = gcf_open("/dev/ttya", speed);	/* open the serial port */
		
		/* infinite read loop till connection closes */
		while ( (block_no = gcf_read(gfd, &cptr) != -1) {

			if (gcfhdr_read(cptr, &hdr, GCFTP) == -1)
				gerror("GCF Decodeing error, read serial data");
		
			gcfhdr_print(&hdr, stdout); 
		}

.fi
.SH DEBUGGING
.LP
There  exists a debugging version of the library libgcf_debug.a that can be compiled with
the application. This version contains numerous verbose statements  printed to standard 
error that can be used to establish the performance of the functions.

.SH GCF ERRORS
.LP
The \fBgcfhdr_read\fR conversion function returns an internal error number to an external integer 
variable named gcf_error. The error message can be printed to standard error 
using the \fBgerror\fR function.
These errors usually indicate a problem with the DM24 and not with transmission since the
packet passed the transmission checksum verification when \fBgcf_read\fR obtained it.
.TP
.SM ERR_SRATEBAD
The sample rate in the GCF packet is not an even number.
.TP
.SM ERR_REVINTBAD
The reverse integration constant does not match the calculated value.
.TP
.SM ERR_TIMEBAD
The GCF timecode is greater than 23:59:59 (in the number of seconds).
.TP
.SM ERR_COMPCODEBAD
The GCF compression code is not 1, 2, or 4.
.TP
.SM ERR_DURATNBAD
The block duration is not an even number of seconds.
.TP
.SM ERR_SYSIDBAD
The system ID is suspicious and probably not valid.
.TP
.SM ERR_FRSTDIFBAD
The  first difference value is not zero.
.SH "SEE ALSO"
.BR termios,
.BR gcfutil
.SH AUTHORS
Paul Friberg & Sid Hellman, ISTI, Copyright 1998
